# vue-schema-widget

## Description

This library is a data-oriented [vuejs](https://vuejs.org/) component generator, thanks to the component `widget` and 3 optional parameters :
- `json schema`
- `data`
- `conf` which is the glue between the `view` to generate, `data description`, `data value` and `data processing`.

This library is inspired from form generators with more functionalities used in the project [3-6-9-12 pocket](pocket.3-6-9-12.org), cause I wanted to do more design than just bind data with `v-model` directives.

## Features

- bind a data and content values to several components thank to the directive `v-bind.sync` and `v-on` (when several fields need to be synced with one component).
- simple, flexible and dynamic configuration object for generating components at a different level in the same object (inside, above and around the component) which mix json and javascript functions if necessary.
- notify about precise change in a data object.
- rich validation functionality related to a json schema or custom validation.
- best effort : generate schema and data on the fly if one of both is not given.
- agnostic from javascript libraries : do not inherit from any library.

## Dependencies

- depends on :
  - vuelidate 0.6.1
  - uuid 3.3.2

## Examples

### Simple boolean component

```html
<widget :schema="{type: 'boolean', name: 'happy'}" />
```

Generate a simple checkbox with the label 'happy'.

### Object composition

```javascript
let data // without value, it will be generated by the widget

const schema = {
  type: 'object',
  properties: {
    a: {
      type: 'string',
      default: 'twist'
    },
    b: {
      type: 'boolean'
    }
  }
}

// only display the property 'a'
// if you want to render all data properties, you can use avoid the configuration or use {inner: true}
const conf = {
  inner: 'a'
}

const dirty = ({data, value, path}) => {
  console.log(`new value 'a' (${value}) for data ${data} at path ${path}`)
}
```

```html
<widget :schema="schema" :conf="conf" @dirty="dirty" v-model="data" />
```

Generate an input text field with the property `a` of an object.

And stay synced with data modification with respecting

- `data`: data value,
- `oldData`: old data value
- `value`: specific modified value (here `a`)
- `oldValue`: specific old modified value (here default schema value `'twist'`)
- `path`: value path from data. Here `/a`

> `v-model` and `:data.sync` have same behavior

> You can also stay synced with schema (attribute `:schema.sync`) if this last is generated from the data.

### More complete example

A list of 4 elements with several data-binding

```javascript
const data = {
  a: 1,
  b: 'b',
  c: [1, 2],
  d: true
}

const conf = {
  container: [{is: 'div', props: {class: 'row'}}, 'ul'], // containers are div and ul
  before: [{ // two before widgets
    path: '/a', // bind to data.a
    html: ({data, value, name}) => `<li><h2>${name}=${data.a}=${value}</h2></li>` // with directive v-html, dynamically display in markup h2 "a=1=1"
  }, {
    is: 'h3', // second list element
    container: 'li' // inside a markup h3
    text: 'second list element' // with directive v-text
  }],
  is: 'li',
  inner: { // 3 inner widgets
    b: {
      is: 'input',
      props: {
        placeholder: ({value, name}) => `${name} = ${value}` // b = b
      },
      input: ({$t}, value) => `${value} (translation: $t(${value})`, // add translation before the component receives the data-binding
      handlers: {
        click: () => alert(`b widget is clicked`) // display message when this widget is clicked
      }
    },
    'c/1': true, // display default component for the data.c[1] value
    c: true, // display default component for all data.c items
    d: {
      model: {
        prop: 'checked',
        event: 'change'
      }
    }
  },
  after: {
    container: 'li',
    is: 'h4',
    text: ({$t}) => `${t('last')} element` // dynamic translation if the plugin i18n is installed on the widget instance
  }
}
```

```html
<widget :conf="conf" :data="data" />
```

Equivalent to

```html
<div class="row">
  <ul>
    <li><h2>a=1=1</h2></li>
    <li><h3>second list element</h3></li>
    <li>
      <input placeholder="b=b" :value="data.b" @input="data.b = arguments[0]" @click="..." />
      <input type="number" :value="data.c[1]" @input="data.c[1] = arguments[0]" />
      <input type="number" :value="data.c[0]" @input="data.c[0] = arguments[0]" />
      <input type="number" :value="data.c[1]" />
      <input type="checkbox" :checked="data.d" @change="data.d = arguments[0]" />
    </li>
    <li><h4>dernier element</h4></li>
  </ul>
</div>
```

### Add default components

Example with [Quasar](https://quasar-framework.org/)

First, define your components

```javascript
const components = {
  field: 'q-field',
  'field-2': {
    is: 'q-field',
    labelWidth: 2
  },
  'col-2': {
    is: 'div',
    class: 'col-2'
  },
  row: {
    is: 'div',
    class: 'row'
  }
}
```

Specify them at installation time

```js
import {VueSchemaWidget} from 'vue-schema-widget'
Vue.use(VueSchemaWidget, {components})
```

Dynamically

```javascript
import {setComponentsByTypes} from 'vue-schema-widget'

setComponentsByTypes(newComponents)
```

Or locally

```html
<widget :components="components" />
```
## Installation

### Library

Using npm:

```
$ npm install vue-schema-widget
```

Using yarn:

```
$ yarn install vue-schema-widget
```

### Plugin

```javascript
import {Plugin, Widget} from 'vue-schema-widget'
import Vue from 'vue'

// optionally with custom default configurations
cons = {
  field: 'q-field',
  row: {
    is: 'div',
    props: {
      class: 'row'
    }
  },
  boolean: 'q-checkbox',
  string: ({selfSchema}) => {
    switch (selfSchema.format) {
      case 'date-time':
      case 'date':
      case 'time':
        return {
          is: 'q-datetime',
          props: {
            type: selfSchema.format.replace('-', '')
          }
        }
      default:
        if (selfSchema.enum) {
          return {
            is: 'q-select',
            props: {
              options: selfSchema.enum.map(
                value => ({
                  value,
                  label: value
                })
              )
            }
          }
        }
        return 'q-input'
    }
  },
  search: 'q-search',
  number: {
    is: 'q-input',
    props: {
      type: 'number'
    }
  }
}

// apply the plugin
Vue.use(
  Plugin,
  { components } // optional
)
// register globally the widget
Vue.component('widget', Widget)
```

## Widget properties

- schema [optional, Object|Function]: json schema used to identify data fields. By default, it is generated from input data (or empty object description if data is not given).
- data [optional]: data to bind to generated components. By default, generated from the schema (or empty object if schema is not given).
- conf [optional, Object|String|Function]: configuration file which specifies which components, handlers and props to generate, and data-binding.
- id [String]: widget id. Default is uuid.v4().
- scope [Object]: data shared with children widgets.
- dirties [Object]: dirty data values by path.
- isDirty [Boolean]: true iif widget value has been modified.
- errors [Object]: data value errors by path.
- hasErrors [Boolean]: true if errors is not empty.
- $v [Object]: vuelidate instance. Might disappear in a future release.

In addition to generate one component binding like schema-form generation library do, this library provides two concerns: top-down and bottom-up approach

## Widget events

### dirty

fired once a value of data is modified. Parameters are:

- `data`: modified data
- `oldData`: copy of data before the modification
- `value`: modified value
- `oldValue`: coy of value before the modification
- `path`: modified value path

### update:data

fired once the data is created/modified

### update:schema

fired once the schema is generated

## Widget computed properties

- `path`: current path (false if data not bound)
- `value`: current value
- `name`: current value/schema name (last path entry)
- `selfSchema`: current schema
- `type`: current schema type
- `component`: normalized component configuration

## Widget methods

- `updateValue(value)`: update widget `value`.
- `getPath(path) => path`: get a relative path from current `path` or absolute from `/`
- `getValue(path) => value`: get a value absolute path from `data` or relative to current `value`
- `add(value, key)`: add a value in current `value` content (object and array types). If value is undefined, it will be automatically generated from schema description
- `remove(key)`: remove a content value at key pos
- `move(from, to)`: according to Object and Array, move a value from the key `from`, to the key `to`
- `moveForward(pos)`: move forward an array item at key `key` (key + 1)
- `moveBackward(pos)`: move backward an array item at key `key` (key - 1)
- `defaultData()`: calculate default data
- `defaultValue()`: calculate a default value related to widget path
- `getConf(name)`: get a specific conf property related to current `conf`

## Component generation

### The container: top-down

```html
<container>
  <before />
  <widget :conf="conf without first container"/>
  <after />
<container>
```

### The content: bottom-up

```html
<component>
  <inner />
</component>
```

Where

- `container` is (a set of) component(s) (div, card, etc.) embed in each other, which contain at least one `widget`.
- `before` and `after` are components to generate around the contained widget (title, blockquote, etc.).
- `widget` is the recursive widget component.
- `component` is a vuejs dynamic component to display and to bind to the data.
- `inner` is (a set of) component(s) inside the final component to display (slots, object properties, array items, etc.).

All are specified by the conf properties...

## Conf

A conf is the configuration for generating data-bound components.

> All fields can be setted with a function which takes in parameter the widget with all its properties in order to allow to access to all plugins (redux, axios, etc.)

> Example :
```javascript
// show widget only if the widget has a specific property show equals true
show: cmpt => cmpt.show === true
```

### is

Default is schema type.

Types are Function, String, vuejs Component.

Bound to the special attribute [`is`](https://vuejs.org/v2/api/#is).

### props

Default is empty object.

Types are Function and Object.

Bound to the component property [`v-bind.sync`](https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier).

`class` and `style` can be setted in this property.

### handlers

Default is empty object.

Types are Function and Object.

Bound to the component property [`v-on`](https://vuejs.org/v2/api/#v-on).

### show

Default is true.

Types are Function and Boolean.

Bound to the component property [`v-if`](https://vuejs.org/v2/api/#v-if).

### path

Default is '.'

Types are Function|String|Boolean

Data-binding path from data. If false, the data is not bound to the widget (deactive data injection respecting `v-model` or `inner` specific to schema type).

The syntax respects the file system hierarchy.

Examples :

Let a data `D = {first: {second: 2}}`:

#### Absolute path from `D`
- '/' -> D
- '/first' -> {second: 2}
- '/first/second/' -> 2

#### Relative path from `D.first`
- '../' -> D
- '..' -> D
- '../../..' -> D
- './' -> D.first
- '.' -> D.first
- 'second' -> 2
- './second' -> 2
- 'second/.' -> 2
- 'second/./../second' -> 2

### input & output

Those both functions are fired respectively when a specific value is given/updated to a vuejs component.

If they return a value, the new value is used instead of the default value.

### sync

In addition to path, you can bind several properties to widget props, in using the [vuejs sync pattern](https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier).

Types are Function|String|Object|Array[String]|Array[Object]

String specifies which data property name bind to the component.

Object is composed of remainder elements:

- `name`: String, data property name to sync
- `prop`: optional String, component property name. Above `name` by default
- `handler`: optional Function, specific updater function.

String specifies data property name.

#### Examples:

```javascript
// String 'prop' corresponds to
{
  prop: this.value.prop
}
// given to the attribute v-bind.sync

// Array ['prop1', 'prop2'] corresponds to
{
  prop1: this.value.prop1,
  prop2: this.value.prop2
}
// given to the attribute v-bind.sync

// Object {prop1: 'propOne', prop2: propTwo} corresponds to
{
  propOne: this.value.prop1,
  propTwo: this.value.prop2
}
// given to the attribute v-bind.sync
```

### html

Types are Function and String

Bound to the component property [`v-html`](https://vuejs.org/v2/api/#v-html).

### text

Types are Function and String

Bound to the component property [`v-text`](https://vuejs.org/v2/api/#v-text).

### container

(List of) Container conf(s) to apply above the component (div, table, list, transition, [vuedraggable](https://github.com/SortableJS/Vue.Draggable), etc.).

Types are Function|Boolean|String|Object|Array[Function|String|Object]

A boolean specifies if the container is a simple markup *div*.

A String specifies the field `is` of the container to render.

An object specifies a `widget configuration`.

These conf do not handle `container`, `before`, `after` and `inner` properties.

### before

(List of) conf(s) to apply before (at the same level) the component inside a `container` (title, etc.).

Types are Function|String|Object|Array[Function|String|Object]

A String specifies the field `is` of the before to render.

An object specifies a `widget configuration`.

### after

(List of) conf(s) to apply after (at the same level) the component inside a `container` (blockquote, etc.).

Types are Function|String|Object|Array[Function|String|Object]

A String specifies the field `is` of the after to render.

An object specifies a `widget configuration`.

### inner

(List of) children conf(s) to apply inside the final component.

Types are Function|Boolean|String|Object|Array[Function|String|Object]

If the schema is of type *object* or *array*, you can ease data-binding according to remainder description.

#### object

- Boolean : if true, display all schema properties
- String : `path` of schema property to (un)bind/display
- Object : `conf` of property to display by path. Regex path designates a base conf pattern properties
- Array : `items` are above String and `conf`

#### array

- Boolean : if true, display all items according to schema `items`/`additionalItems`
- String : `is` of items to display
- Object : `conf` of all items
- Array : `items` are above String and Object related to item position

#### otherwise

Same behavior as `container`, `before` and `after` properties.

### slot

(List of) slot conf(s) to apply inside the final component.

Types are Function|String|Object|Array[Function|String|Object]

Precise slot name is possible with the name conf property.

### model

Specifies on which model property and event to bind the widget value.

Default is {prop: 'value', event: 'input'}

Types are Function|String|Array[String]|Object

Related to the specialization of the directive [`v-model`](https://vuejs.org/v2/guide/components-custom-events.html#Customizing-Component-v-model), it is possible to specify on which property and event bind a widget value.

According to a model conf property `Model`

String: model prop name
Array of String: [model prop name, model event name]

### inherit

Default is true.

Types are Function|Boolean

If true, current conf inherits from a default conf.

## Perspectives

- Stop to depends on [`vuelidate`](https://monterail.github.io/vuelidate/)
- Handle several schema definition type (xml, xsd, etc.)
- Handle `container`, `before`, `after`, `inner` and `innerType` in `container conf`
- Provide a new mix of html and conf language in order to generate vuejs component with enriched data-binding
